# 원칙

### p.91
리팩터링 하지 말아야할 때도 존재한다.
굳이 수정할 필요가 없을 때엔, 그냥 지나치자.
필요에 의해 **내부 동작을 이해해야 할 시점**에 리팩터링을 해야 효과를 제대로 본다.
- 사실 지금까지 불편한 코드가 보이면 그 즉시 수정을 진행했다.
하지만 코드의 정상동작을 확신하지 못하면서 코드를 리팩터링 하는건 어리석은 일이었다.
코드는 생각보다 복잡하고 엮여져 있기 때문에
지금 당장 확실하지 않으면 건드리지 않는 쪽이 좋겠다.

### p.95
브랜치 관리는 어떻게 해야 좋을까?
CI(Continuous Integration)에 따르면, 모든 팀원이 하루에 한번은 마스터와 통합한다고 한다.
다양한 팀원들과 협업을 할때 지속적인 update가 되지 않아 고민이 많을때엔 이런 방법을 써도 좋을 것 같다.
하지만, 이는 master 브랜치를 건강하게 관리하는게 중요하다.
건강하게 관리하는 법은 거대한 기능을 잘게 쪼개고, 각 기능을 쪼갤 수 있는 feature toggle(feature flag)을 적용하여 전체적으로 망가지지 않게 관리해야한다.


### p.102
상당수의 프로젝트에서 애자일을 적용하고 있어 '애자일 사고'가 주류로 자리잡았다.
하지만, '애자일'을 내세우는 프로젝트 중 이름만 애자일인 경우가 대부분이다.
- 애자일을 제대로 적용하려면, 리팩터링에 대한 임의 역량과 열정이 뒷받침 되어야 자연스럽게 스며들도록 한다.
4년차가 되면서 단 6개월 동안 위의 과정을 거쳐왔다. 6개월동안 참 좋았는데, 옳은 과정을 거쳤던걸까?애자일을 잘 쓰는 방법의 정답은 무엇일까?


### p.103
리팩터링 하면 성능이 느려진다? 그럴수 있다.
하지만, 하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은
먼저 튜닝하기 쉽게 만들고 나서 얼마든지 가능하다.
즉, 리팩토링 이후에 얼마든지 빠르게 구현해내는 것이 가능하다.


### p.105
대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다.
즉, 코드 전체를 고르게 최적화한다면 거의 90%는 효과가 거의 없기 때문에 시간낭비..

의도적으로 성능 최적화에 돌입하기 전까지는 코드를 다루기 쉽게 만드는 것에 집중하자.
